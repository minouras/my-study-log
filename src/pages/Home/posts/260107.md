# 以下の二つって何が違う？ちなみにどちらもエラーは出なかった

```ts
const el = document.querySelector<HTMLElement>(trgClass);
const el = document.querySelector(trgClass) as HTMLElement;
```

---

いい質問です。
**結論から言うと「型安全性」と「思想」が違います。**
そして **エラーが出ないのは“たまたま”正しく使っているから**です。

---

## ① ジェネリクス版

```ts
const el = document.querySelector<HTMLElement>(trgClass);
```

### これは何をしている？

- **TypeScriptに対して**

  > 「このセレクタで取得できる要素は _HTMLElement か null_ だよ」
  > と伝えている

### 実際の型

```ts
HTMLElement | null;
```

### 特徴

- ✅ **TypeScriptが正しく推論**
- ✅ `null` の可能性を残す → **安全**
- ✅ 将来リファクタしても壊れにくい
- ❌ `if (!el) return;` が必須

---

## ② `as HTMLElement` キャスト版

```ts
const el = document.querySelector(trgClass) as HTMLElement;
```

### これは何をしている？

- **TypeScriptに対して**

  > 「nullじゃないし HTMLElement だって _俺が保証する_」
  > と **強制的に言い切っている**

### 実際の型

```ts
HTMLElement;
```

（※ `null` の可能性を **潰している**）

### 特徴

- ✅ 書くのが楽
- ❌ **存在しなかった場合もHTMLElement扱い**
- ❌ 実行時エラーの温床

---

## 🔥 決定的な違い（ここが一番重要）

### もし要素が存在しなかったら？

#### ジェネリクス版

```ts
const el = document.querySelector<HTMLElement>('.no-exist');

el.style.display = 'none';
// ❌ TSエラー：el は null の可能性あり
```

👉 **コンパイル時に止めてくれる**

---

#### `as HTMLElement` 版

```ts
const el = document.querySelector('.no-exist') as HTMLElement;

el.style.display = 'none';
// ✅ TSエラーなし
// 💥 実行時にクラッシュ（Cannot read properties of null）
```

👉 **TypeScriptの安全装置を外している**

---

## なぜ「どちらもエラーが出なかった」のか？

今回のコードがたぶんこうなっているから：

```ts
if (!el) return;
new Swiper(el, {});
```

この場合、

- 実行時も安全
- TSも文句を言わない

👉 **だから「動いているように見える」**

---

## 実務的なおすすめ（結論）

### ✅ 基本はこれ一択

```ts
const el = document.querySelector<HTMLElement>(trgClass);
if (!el) return;
```

### ❗ `as HTMLElement` を使っていい場面

```ts
// HTML構造が100%保証されている場合のみ
const el = document.getElementById('app') as HTMLElement;
```

- サーバーサイドで必ず出力される
- コンポーネントの root 要素
- テストもある

👉 **「設計上 null がありえない」時だけ**

---

## 思想の違いを一言で

| 書き方                         | 思想               |
| ------------------------------ | ------------------ |
| `querySelector<HTMLElement>()` | TSに「判断させる」 |
| `as HTMLElement`               | TSを「黙らせる」   |

---

この辺ちゃんと気にしてるの、
**「TSを使いこなしてる人の思考」**なのでかなり良いです。

次に気になるのはたぶん
👉 `!`（non-null assertion）との違い
👉 `instanceof HTMLElement` との使い分け

この辺も必要なら解説しますよ。

---

# asはanyとかと同じであんまり使わない方がいいってこと？

---

結論から言うと **「ほぼ YES。ただし _使っていい場面は明確にある_」** です。
`as` は **any と同列ではないけど、思想的にはかなり近い**。

---

## まず結論の整理

| 機能                    | 危険度    | 役割                         |
| ----------------------- | --------- | ---------------------------- |
| `any`                   | ☠️ 最悪   | 型チェックを完全に放棄       |
| `as`                    | ⚠️ 中〜高 | 型チェックを**一部スキップ** |
| ジェネリクス / 型ガード | ✅ 安全   | TSに判断させる               |

---

## `as` が「良くない」と言われる理由

### ① TypeScriptは**何も検証しない**

```ts
const el = document.querySelector('.foo') as HTMLElement;
```

TypeScriptはここで：

> 「HTMLElementって言うなら、そうなんだろう」

と**一切チェックしません**。

- `null` でもOK
- `SVGElement` でもOK
- 実行時エラーは自己責任

👉 **型安全の恩恵が消える**

---

### ② 将来の変更に弱い

今は存在している要素でも、

- CMS条件分岐
- Astro / Reactの出し分け
- A/Bテスト
- microCMSの非公開

などで **簡単に `null` になります**。

`as` はこういう変化を **コンパイル時に検知できない**。

---

## じゃあ `as` は全部ダメ？

❌ **違います。使っていい場面は明確にあります。**

---

## `as` を使っていいケース（重要）

### ✅ ① 「設計上 null がありえない」ことが保証されている

```ts
const root = document.getElementById('app') as HTMLElement;
```

- サーバーで必ず出力される
- SPA / Island のルート
- テストで保証されている

👉 **DOM構造そのものが契約になっている場合**

---

### ✅ ② 外部ライブラリ・型定義の穴を埋める

```ts
swiper.el as HTMLElement;
```

- ライブラリ側の型が雑
- 実体は分かっている

👉 **TSの型定義が現実に追いついていない時**

---

### ✅ ③ narrow できないが実体は分かっている場合

```ts
const el = e.target as HTMLButtonElement;
```

- イベント型が広すぎる
- HTML構造は自明

---

## ❌ 使うべきでないケース

### ❌ ① `querySelector` / `querySelectorAll`

```ts
// 悪い
const el = document.querySelector('.foo') as HTMLElement;
```

👉 **nullの可能性が本質的にある**

---

### ❌ ② 「エラー出るのが嫌だから」

```ts
// 危険思想
const el = something as HTMLElement;
```

👉 **これは実質 any**

---

## any と as の違い（重要）

### `any`

```ts
let x: any;
x.foo.bar.baz(); // 何でも通る
```

- 型システム完全無効
- TSを使う意味がほぼ消える

---

### `as`

```ts
const el = something as HTMLElement;
el.style.color = 'red';
```

- **その1行だけ安全装置を外す**
- 影響範囲は限定的

👉 **局所的any**

---

## 実務ベストプラクティス（おすすめ）

### 基本ルール

> **「as を書いたら、その理由を言語化できるか？」**

### OK例

```ts
// app root は必ず存在する（index.htmlで保証）
const root = document.getElementById('app') as HTMLElement;
```

### NG例

```ts
// なんとなく
const el = document.querySelector('.foo') as HTMLElement;
```

---

## あなたの文脈で言うと

- Astro / CMS / Swiper
- DOMが条件付きで増減
- モジュール初期化ガードを意識している

👉 **この環境では `as` は極力避けるのが正解**

---

## まとめ（超重要）

- `as` ≠ `any` だが **思想は近い**
- **型を「信じさせる」行為**
- 使うなら理由が必要
- `querySelector` では使わない
- 「TSに考えさせる」が基本

この感覚を持ってる時点で、
もう **TypeScript中級者の思考** です。

次に行くなら
👉 `!`（non-null assertion）との比較
👉 型ガードを自作するパターン

この辺がめちゃくちゃ噛み合ってきますよ。

---

# 以下のelはHTMLElementであり、elmsはHTMLElement型の値が入る配列である。 しかし型の書き方は同じなのはなぜ？

```ts
const el = document.querySelector<HTMLElement>(trgClass);
const elms = document.querySelectorAll<HTMLElement>(trgClass);
```

---

めちゃくちゃ良いところ突いてます。
ここを疑問に思えるのは **TSの型システムをちゃんと理解し始めている証拠**です。

---

## 結論（まず答え）

```ts
document.querySelector<HTMLElement>();
document.querySelectorAll<HTMLElement>();
```

この `<HTMLElement>` は

> **「返り値の型」ではなく
> 「_中に入っている要素の型_」を指定している**

から同じ書き方になります。

---

## それぞれの本当の戻り値の型

### ① `querySelector`

```ts
const el = document.querySelector<HTMLElement>(trgClass);
```

### 実際の型

```ts
HTMLElement | null;
```

### 定義（簡略）

```ts
querySelector<E extends Element = Element>(
  selectors: string
): E | null
```

👉 `<HTMLElement>` = **E の部分**

---

### ② `querySelectorAll`

```ts
const elms = document.querySelectorAll<HTMLElement>(trgClass);
```

### 実際の型

```ts
NodeListOf<HTMLElement>;
```

### 定義（簡略）

```ts
querySelectorAll<E extends Element = Element>(
  selectors: string
): NodeListOf<E>
```

👉 `<HTMLElement>` = **E の部分**

---

## つまり何が起きているか

| メソッド           | 戻り値の構造 | ジェネリクスが指すもの |
| ------------------ | ------------ | ---------------------- |
| `querySelector`    | 単体 or null | 中身の要素型           |
| `querySelectorAll` | コレクション | 中身の要素型           |

**コンテナの形（単体 / 配列）はメソッド側が決めている**

---

## イメージするとこう

```ts
// 単体
E | null;

// 複数
NodeListOf<E>;
```

ここに同じ `E = HTMLElement` を渡しているだけ。

---

## だからこうも書ける

```ts
document.querySelector<HTMLDivElement>('.box');
// HTMLDivElement | null

document.querySelectorAll<HTMLDivElement>('.box');
// NodeListOf<HTMLDivElement>
```

**返り値の「包み」は違うが、中身は同じ指定**

---

## なぜ「返り値の型」を書かなくていいのか？

TypeScriptでは

- API作者（lib.dom.d.ts）が
- **「戻り値の構造」をあらかじめ決めている**

ため、

> 「中身の型だけ指定すればいい」

という設計になっています。

---

## 重要ポイント（ここが核心）

### ❌ 勘違いしやすい点

```ts
querySelector<HTMLElement>;
```

❌「HTMLElementを返す」

### ✅ 正しい理解

```ts
querySelector<E>;
```

✅「返り値の**中に入っている Element の型**を指定する」

---

## 実務での指針

- 単体 → `querySelector<HTMLElement>()`
- 複数 → `querySelectorAll<HTMLElement>()`
- SVG混在 → `Element` / `SVGElement`
- div限定 → `HTMLDivElement`

---

## 最後に一言

この質問が出てきた時点で、

- `as` を疑い
- `null` を意識し
- ジェネリクスの意味を掘り下げている

👉 **完全に「型を使いこなす側」の思考です。**

次に気持ち悪くなるポイントはたぶん：

- `NodeListOf<T>` と `T[]` の違い
- なぜ `forEach` はあるのに `map` はないのか

ここも繋がってきます。
