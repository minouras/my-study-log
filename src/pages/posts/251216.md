phpの話に戻る。
別のモジュールファイルをインポートして使用する時、以下のように書くと思う。

require_once **DIR** . '/PHPMailer/src/PHPMailer.php';
require_once **DIR** . '/PHPMailer/src/Exception.php';

use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;

この時、useの後には必ずパスを書かないといけないのか？
require_onceでパス指定してファイルを取ってるんだからPHPMailer.phpとかだけで行けそうな気もするけど、それがPHPの仕様？

めちゃくちゃ良いところ突いてます。
ここ PHPで一番混乱しやすいポイントの1つ です。

結論から言うと👇

結論（超重要）

require_once のパス指定と、use の指定は「完全に別物」

use の後ろに書くのは
「ファイルパス」ではなく「名前空間（namespace）」

だから
PHPMailer.php みたいな書き方はできない（仕様）

まず役割を分けて考える
① require_once
require_once **DIR** . '/PHPMailer/src/PHPMailer.php';

役割：

PHPファイルを読み込む

クラス定義を メモリに載せる

👉
「このクラス定義、使える状態にして」

② use
use PHPMailer\PHPMailer\PHPMailer;

役割：

名前空間のエイリアス（省略名）を作る

ファイルは一切読み込まない

👉
「この長い名前を短く呼べるようにして」

ここが最大の勘違いポイント
❌ よくある誤解

require_once でファイル取ってるんだから
use PHPMailer; でいけるんじゃ？

✅ 実際のPHP仕様
// PHPMailer.php の中
namespace PHPMailer\PHPMailer;

class PHPMailer {
...
}

この時点で
クラスの本名（完全修飾名）はこれ👇

PHPMailer\PHPMailer\PHPMailer

use は「クラス名の別名宣言」
use PHPMailer\PHPMailer\PHPMailer;

// これは実質こう書いてるのと同じ
$mail = new PHPMailer\PHPMailer\PHPMailer();

もし use を書かないなら👇

$mail = new \PHPMailer\PHPMailer\PHPMailer();

なぜ use PHPMailer.php がダメなのか
理由1：use はファイルを見ていない

PHPは use 時に

そのファイルがどこにあるか

どんな名前か
一切見ない

理由2：PHPは「クラス名 ≠ ファイル名」
class Foo {}

ファイル名：hoge.php

クラス名：Foo

👉 PHPは全然気にしない

require と use の対応関係は「人間の慣習」
PHPMailer/src/PHPMailer.php
└─ namespace PHPMailer\PHPMailer;
└─ class PHPMailer

たまたま

フォルダ構成

namespace

が揃ってるだけ。

👉 PHPの言語仕様では一切リンクしてない

なぜ Node / TypeScript みたいに書けないのか
Node / TS
import { PHPMailer } from './PHPMailer';

ファイルパス = モジュール

export / import が直結

PHP
require_once 'PHPMailer.php';
use PHPMailer\PHPMailer\PHPMailer;

ファイル読み込み

名前空間解決

が 完全に分離

じゃあ「楽する方法」は？
Composer を使う（現代PHP）
require_once 'vendor/autoload.php';

use PHPMailer\PHPMailer\PHPMailer;

パス書かなくていい

オートロード

namespace とファイル構成が自動対応（PSR-4）

👉 今どきのPHPはほぼこれ前提

まとめ（ここだけ覚えて）

require_once → ファイルを読む

use → 名前空間を省略する

use の後ろは ファイルパスではなく namespace

ファイル名とクラス名は PHP仕様上無関係

Node.js 的な import とは思想が違う
