わかる、その沼はマジでハマりがち…
今回の `image-size` の件は **「ESM / CJS の違い＋export 形の違い＋型（Buffer/パス）」**が全部絡んだ“フルコンボ”でした。

今後ラクになるように、**Node での ESM / CJS の扱い方と、沼った時のチェック手順**を整理しておくね。

---

## 1. そもそも CJS と ESM って何が違う？

### CommonJS（CJS）

- 昔からある Node の標準
- `require` / `module.exports` の世界
- 主な特徴：

  ```js
  // 読み込み
  const foo = require('foo');
  const { bar } = require('foo');

  // 書き出し
  module.exports = fn;
  module.exports = { fn, util };
  ```

### ES Modules（ESM）

- ブラウザ標準の import/export
- Node でも公式対応
- `import` / `export` の世界
- 主な特徴：

  ```js
  // 読み込み
  import foo from 'foo';
  import { bar } from 'foo';

  // 書き出し
  export default fn;
  export const util = () => {};
  ```

---

## 2. Node が「このファイルは CJS or ESM」と判断する条件

Node の判断ルール：

### ① `package.json` の `"type"` フィールド

- `"type": "module"` がある
  → その package 内の `.js` は **ESM**
- `"type": "module"` がない（または `"commonjs"`）
  → `.js` は **CJS**

### ② 拡張子での指定

- `.mjs` → 強制的に **ESM**
- `.cjs` → 強制的に **CJS**

今回の `add-img-size.mjs` は ESM だから：

- `require` はそのままでは使えない
- `createRequire(import.meta.url)` を使って CJS の require を“召喚”した

---

## 3. 代表的なエラーパターンと意味

### ❌ `ReferenceError: require is not defined in ES module scope`

→ 「ESM ファイル（.mjs や type: module）内で `require` を直書きした」

**対処：**

```js
import { createRequire } from 'node:module';
const require = createRequire(import.meta.url);
const mod = require('some-cjs-module');
```

---

### ❌ `SyntaxError: Cannot use import statement outside a module`

→ 「CJS（.cjs や type: commonjs）ファイルで `import` を使った」

**対処：**

- `require` に書き換える
- もしくはファイルを `.mjs` にする / `type: "module"` にする

---

### ❌ `X is not a function`

```js
const mod = require('foo');
mod(); // ←ここで X is not a function
```

or

```js
import foo from 'foo';
foo(); // ←ここでエラー
```

→ 「モジュールの export 形と、こっちの import 形が噛み合ってない」

例えば、モジュール内部が：

```js
// CJS側
module.exports = { imageSize };
```

なのに：

```js
const sizeOf = require('image-size'); // { imageSize: [Function] }
sizeOf(...); // ❌ オブジェクトに対して呼び出してる
```

**こうするべき：**

```js
const { imageSize } = require('image-size');
imageSize(...);
```

or

```js
const imageSizeModule = require('image-size');
console.log(imageSizeModule); // 形を確認してから使う
```

---

## 4. 「ESM ファイルで CJS モジュールを使う」基本パターン

今回やったパターンそのもの👇

```js
// ESM ファイル (.mjs / type: module) 内
import { createRequire } from 'node:module';
const require = createRequire(import.meta.url);

// CJS モジュールを読む
const someModule = require('some-cjs-package');
```

さらに、「モジュールの形が怪しいとき」の鉄板技：

```js
const mod = require('image-size');
console.log(mod);
```

で中身を見てから、こう分岐する：

```js
const sizeOf =
  typeof mod === 'function'
    ? mod
    : typeof mod?.imageSize === 'function'
      ? mod.imageSize
      : typeof mod?.default === 'function'
        ? mod.default
        : null;
```

---

## 5. 「CJS ファイルで ESM パッケージを使う」パターン（逆パターン）

逆に CJS 側で ESM パッケージを使うときは `import()` を使う。

```js
// CJS ファイル (.cjs / type: commonjs 内の .js)
(async () => {
  const { default: foo, bar } = await import('some-esm-package');
  foo();
})();
```

※ Astro まわりは ESM 前提なので、今回こちらは出てこなかったけど、頭の片隅に。

---

## 6. 今回の `image-size` で起きていたこと

1. 最初は

   ```js
   import { imageSize } from 'image-size';
   imageSize(imgPath);
   ```

   → ESM 版 / CJS 版 / export 形の不一致で中身が undefined / 予想外オブジェクトになり、
   `TypeError: imageSize is not a function` の流れ。

2. 次にパス文字列を渡したら、内部で `TextDecoder` エラーが出た。

   ```txt
   The "list" argument must be an instance of SharedArrayBuffer, ArrayBuffer or ArrayBufferView.
   ```

   これは **「image-size が Buffer 前提なのにパス文字列を渡している」**という意味。

3. そこで：
   - CJS として読み込み（`createRequire`）
   - 中身の形をなんでも扱えるようにラッパーを用意
   - `fs.readFileSync(imgPath)` で Buffer を渡すように変更

   という「ESM/CJS/Buffer 全部を丸く収める」実装になった。

---

## 7. ESM / CJS 周りで沼りにくくするチェックリスト

実務でサクッと確認するための **5 ステップ** をまとめると：

### ① いま書いているファイルは ESM or CJS？

- `.mjs` → ESM
- `.cjs` → CJS
- `.js` → `package.json` の `"type"` で決まる
  - `"type": "module"` → ESM
  - それ以外 → CJS

→ **ESMなら `import`、CJSなら `require`** が基本。

---

### ② ライブラリ側は ESM or CJS?

`node_modules/xxx/package.json` を見る：

- `"type": "module"` がある？
- `"main"`, `"module"`, `"exports"` に何が書いてある？

最悪わからなければ：

```bash
node -e "console.log(require('image-size'))"   // CJSファイルで
# or
node -e "import m from 'image-size'; console.log(m)" --input-type=module
```

で中身を見るのが早い。

---

### ③ エラーが出たらまず型を見る

- `X is not a function` → import 形 or export 形が噛み合ってない
  - `console.log(mod)` で中身を見る

- `Cannot use import statement outside a module` → CJS で import 使ってる
- `require is not defined` → ESM で require 直書きしてる

---

### ④ Node の ESM ファイルから CJS を読むときは `createRequire`

```js
import { createRequire } from 'node:module';
const require = createRequire(import.meta.url);
const mod = require('some-cjs');
```

---

### ⑤ ライブラリが Buffer 前提かどうかは docs + エラーメッセージで判断

- `TextDecoder` / `ArrayBufferView` 周りのエラー
- `The "list" argument must be an instance of ...` など

→ 「文字列じゃなくて Buffer を寄越せ」のサインなので、
`fs.readFileSync(path)` してから渡す。

---

## 8. 実務的なスタンス

正直、**ESM / CJS を完全に暗記する必要はなくて**、

- 「今いる世界は ESM か CJS か？」
- 「ライブラリの中身は `console.log` で見ればいい」
- 「わからんときは `createRequire` で CJS 側を呼び出せばたいていなんとかなる」

くらいのノリで十分です。

今回の `add-img-size.mjs` が、
**「ESMファイルからCJSライブラリを扱う」「中身の export 形が怪しいライブラリもとりあえず動かす」お手本パターン**になっているので、
また似たバッチ書くときはこのスクリプトをベースにしてもらうとかなりラクだと思います 💪
